/**
 * Copyright 2015 Sky Wickenden
 *
 * This file is part of StreamBed.
 * An implementation of the Babbling Brook Protocol.
 *
 * StreamBed is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * at your option any later version.
 *
 * StreamBed is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with StreamBed.  If not, see <http://www.gnu.org/licenses/>
 *
 * @fileOverview This is the domus domain version of interact.js
 * Important :    The different domain interact.js files are seperate files despite the fact they could be
 *                consolidated in order to prent obscure security issues. Each file should remain as simple as possible
 *                in order to prevent opening up holes.
 * @author Sky Wickenden
 */

// Create the BabblingBrook namespace
if (typeof BabblingBrook !== 'object') {
    BabblingBrook = {};
}
if (typeof BabblingBrook.Domus !== 'object') {
    BabblingBrook.Domus = {};
}

/**
 * @namespace Gloabl interaction class. Used for posting and recieving messages from the domus subdomain to the rhythm,
 *            scientia and client domains.
 * @package JS_Domus
 */
BabblingBrook.Domus.Interact = (function () {
    'use strict';

    /**
     * @type {object} callbacks success and error callbacks for each message sent.
     * @type {string} callbacks.<action_uid> The UID of a request that was sent out
     *                                       that is used to identify an incoming request.
     * @type {function} callbacks.<action_uid>.success The success callback.
     * @type {function} callbacks<action_uid>.error The error callback.
     */
    var callbacks = {};

    /**
     * @type {object} A collection of window references from client requests. Indexed by request_uuid.
     */
    var windows = {};

    /*
     * Report an error message for an incoming message.
     *
     * IMPORTANT Do not send error reports back to the domus, this can result in infinite recursion loops.
     * The domus request should handle such errors in a timeout.
     *
     * @param {string} error_message A message about the error.
     * @param {string} event The event object that was generated by the message from this domus domain.
     *
     * @return void
     */
    var reportError = function (error_message, event) {
        console.error('domus/interact.js error : ' + error_message);
        console.log(event);
        throw 'Thread execution stopped.';
    };

    /**
     * Store a window reference for a client request.
     *
     * @param {string} request_uuid The uuid sent with the request from the client.
     * @param {string} client_window The unique window name of the client.
     *
     * @return undefined
     */
    var storeWindow = function (request_uuid, client_window) {
        windows[request_uuid] = client_window;
    };

    /**
     * @type {number} Timestamp of the lasttime that readyRequest ran.
     */
    var ready_timeout;

    /**
     * Receives a ready request from a client and checks that the origin site is permited to access this domus.
     *
     * @param {object} origin_domain The domain that is requesting access to this domus domain.
     * @param {object} The reference to the window object that is requesting domus access.
     *
     * @return void
     */
    var readyRequest = function(origin_domain, event_source) {
        // Only process a maximum of once every five seconds.
        var now =  Math.round(new Date().getTime() / 1000);
        if(typeof ready_timeout !== 'undefined') {

            if (now - ready_timeout < 5) {
                return;
            }
        }
        ready_timeout = now;

        // Reload the domus data for this client and check that the origin is listed in the site_access
        BabblingBrook.Library.post(
            '/data/domususer',
            {},
            /**
             * Success callback
             *
             * @param {object} user_data See BabblingBrook.Domus.User for details.
             */
            function (user_data) {
                BabblingBrook.Domus.User = user_data;
                if (jQuery.inArray(origin_domain, BabblingBrook.Domus.User.site_access)) {
                    event_source.postMessage('ready', origin_domain);
                } else {
                    event_source.postMessage('accessdenied', origin_domain);
                }
            },
            function () {
                console.error('There was a problem reloading the user_data');
            }
        );
    };

    /**
     * Generate a uuid to be used when sending a request to other domains.
     *
     * Also save the callbacks to use when the request returns.
     *
     * @param {function} successCallback The function to call when the request returns successfully.
     *      It should accept a single data paramater which will contain the requested data.
     * @param {function} [errorCallback] The function to call when the request is unsucssful.
     *      It should contain two paamaters. The first is required and is the error_code.
     *      The second is option and is generic error_data object.
     *      See the protocol definition for documented error objects.
     *      A genreic error callback is generated if one is not provided.
     *
     * @return string The new uuid.
     */
    var generateUUID = function (successCallback, errorCallback, timeout, action, domain) {
        // This uuid is sent to other domains and then passed back with any response.
        var request_uuid = BabblingBrook.Library.generateUUID();
        callbacks[request_uuid] = {};

        if (typeof successCallback !== 'function') {
            console.error(
                'No success function defined when requesting ' + action +
                ' from the ' + window.location.host + ' domain.'
            );
            throw 'Thread execution stopped.';
        }
        callbacks[request_uuid].success = successCallback;
        if (typeof errorCallback !== 'function') {
            errorCallback = function (error_code, error_data) {
                console.error(error_code, error_data);
                console.error(
                    'No error function defined when requesting ' + action +
                    ' from the ' + domain + ' domain.'
                );
                throw 'Thread execution stopped.';
            };
        }
        callbacks[request_uuid].error = errorCallback;

        // Once the request has timed out run the the error callback and then delete this request.
        // Convert the timout time to a time untill timeout.
        var time_until_timeout = 30000;
        if (typeof timeout === 'number') {
            var now = Math.round(new Date().getTime());
            time_until_timeout = timeout - now;
        }
        setTimeout(function () {
            if (typeof callbacks[request_uuid] !== 'undefined') {
                console.log('Domus postMessage timed out whilst waiting for a response : ' + action);
                callbacks[request_uuid].error('domus_request_timed_out');
                delete callbacks[request_uuid];
            }
        }, time_until_timeout);

        return request_uuid;
    };

    /**
     * Post a message to another domain.
     *
     * @param {object} data The data to send.
     * @param {string} [domain] The domain or domain that the message is being sent to.
     *      If this is a request to an scientia domain then it will be the full domain.
     *      If this is a request to the client or rhythm domains it will be a dub domain.
     * @param {string} [request_uuid] The uuid that the domus domain uses to identify this return of requested data.
     *      Only required if this is a return message.
     * @param {string} [action] The name of the action to call in the object (not including 'action' at the start).
     *      Only required if making a request.
     * @param {function} successCallback The function to call when the request returns successfully.
     *      It should accept a single data paramater which will contain the requested data.
     * @param {function} errorCallback The function to call when the request is unsucssful.
     *      It should contain two paamaters. The first is required and is the error_code.
     *      The second is option and is generic error_data object.
     *      See the protocol definition for documented error objects.
     * @param {boolean} [https=false] Should the message be sent via https or not.
     * @param {number} [timeout] A millisecond timestamp for when the request should timeout.
     *
     * @return void
     */
    var postMessage = function (data, domain, request_uuid, action, successCallback, errorCallback, https, timeout) {
/************    !! IMPORTANT  !! ***************
 * This is a temporary insecure hack to prevent use of https.
 ************************************************
 */
        https = false;

        if (typeof timeout === 'undefined') {
            timeout = parseInt(Math.round(new Date().getTime())) + 25000;
        }
        var parent_window, location, message, domus_uuid;

        if (https !== true) {
            https = false;
        }

        // If this is the sending of a ready request rather than the completion of one,
        // then generate a uuid to be associated with it.
        if (action === 'ready') {
            request_uuid = 'ready_request';
        }

        if (typeof action === 'string') {
            request_uuid = generateUUID(successCallback, errorCallback, timeout, action, domain);
            var testing = false;
            if (BabblingBrook.Library.getCookie('testing') === 'true') {
                testing = true;
            }
            message = {
                version : 1,
                request_data : data,
                action : action,
                request_uuid : request_uuid,
                // record the timestamp for when the timeout will occour rather than the time until timeout.
                timeout : timeout,
                testing : testing
            };

        } else {
            var response_uuid = BabblingBrook.Library.generateUUID();
            message = {
                response_data : data,
                request_uuid : request_uuid,
                response_uuid : response_uuid
            };
        }

        message = JSON.stringify(message);

        // Which window are we communicating with?
        if (https) {
            location = 'https://';
        } else {
            location = 'http://';
        }
        if (domain === 'filter') {
            parent_window = document.getElementById(domain).contentWindow;
            location += 'filter.' + BabblingBrook.Domus.User.domain;
        } else if (domain === 'suggestion') {
            parent_window = document.getElementById(domain).contentWindow;
            location += 'suggestion.' + BabblingBrook.Domus.User.domain;
        } else if (domain === 'kindred') {
            parent_window = document.getElementById(domain).contentWindow;
            location += 'kindred.' + BabblingBrook.Domus.User.domain;
        } else if (domain === 'ring') {
            parent_window = document.getElementById(domain).contentWindow;
            location += 'ring.' + BabblingBrook.Domus.User.domain;
        } else if (domain.substr(0, 9) === 'scientia.') {        // Assume it is an scientia domain
            var scientia_domain_id = BabblingBrook.Domus.SendToScientiaFrame.convertDomainToId(domain, https);
            parent_window = document.getElementById(scientia_domain_id).contentWindow;
            location += domain;
        } else if(typeof windows[request_uuid] !== 'undefined') {
            // This is a client request.
            parent_window = windows[request_uuid];
            location += BabblingBrook.Domus.Controller.client_domain;
        } else if (domain === BabblingBrook.Domus.Controller.client_domain) {
            // This is a request for the client.
            parent_window = window.parent;
            location += BabblingBrook.Domus.Controller.client_domain;
        } else {
            console.error('Client window not found for message uuid : ' + request_uuid + ' Action ' + action);
            throw 'Thread execution stopped.';
        }
        // If getting a strange error here to do with syntax, then the location is probably missing the protocol.
        parent_window.postMessage(message, location);
    };

    /**
     * Checks if the origin is an rhythm domain and returns just the sub domain.
     *
     * @param {string} origin The full domain of a message.
     *
     * @return {string} The sub domain or the full domain.
     */
    var stripOrigin = function (domain) {
        if (domain.substr(0, 7) === 'filter.') {
            return 'filter';
        }
        if (domain.substr(0, 11) === 'suggestion.') {
            return 'suggestion';
        }
        if (domain.substr(0, 8) === 'kindred.') {
            return 'kindred';
        }
        if (domain.substr(0, 5) === 'ring.') {
            return 'ring';
        }
        return domain;
    };

    /**
     * The standard error callback that is attatched to all action requests from the domus domain.
     *
     * @param {string} request_uuid The uuid that was sent with the request from the request domain and is
     *      returned to that domain with the response so that it can be identified.
     *      This is not sent by the callbac caller, but bound to the callback in this module.
     * @param {string} origin The domain that the request originated from.
     *      This is not sent by the callback caller, but bound to the callback in this module.
     * @param {boolean} https Should the response be sent over https
     *      This is not sent by the callback caller, but bound to the callback in this module.
     * @param {string} The name of the action that was called.
     * @param {object} Any data that was sent with the request.
     * @param {string} error_code The error code that is being reported with this error.
     *      See BabblingBrook.Models.errorTypes for valid values.
     * @param {object} error_data A generic data object for supplemental data specific to the error.
     *      See the protocol definition for documented error objects.
     *
     * @return void
     */
    var returnErrorCallback = function(request_uuid, origin, https, action, request_data, error_code, error_data) {
        var response_data = {
            error_code : error_code,
            error_data : error_data
        };
        postMessage(response_data, stripOrigin(origin), request_uuid, undefined, undefined, undefined, https);
        var error_message = 'logging error being sent back to ' + stripOrigin(origin) + '.';
        BabblingBrook.Library.logError(error_code, error_data, error_message, 'domus');
    };

    /**
     * The standard success callback that is attatched to all action requests from the domus domain.
     *
     * @param {string} domus_uuid The uuid that was sent with the request from the domus domain and is
     *      returned to the domus with the response so that it can be identified.
     *      This is not sent by the callback caller, but bound to the callback in this module.
     * @param {string} origin The domain that the request originated from.
     *      This is not sent by the callbac caller, but bound to the callback in this module.
     * @param {boolean} https Should the response be sent over https
     *      This is not sent by the callback caller, but bound to the callback in this module.
     * @param {object} response_data A generic data object containg the response to the request.
     *      See the relevant domus test module for valid structures.
     *
     * @return void
     * @refactor rename all uuid refs as uuid.
     * @refactor use console.error rather than throw, as it includes a trace. throw or return in addition
     *      if need to halt execution.
     */
    var returnSuccessCallback = function(domus_uuid, origin, https, response_data) {

        if (typeof response_data !== 'object') {
            console.error('A success callback in the domus domain does not contain a valid data object.');
            throw 'Thread execution stopped.';
        }
        postMessage(response_data, stripOrigin(origin), domus_uuid, undefined, undefined, undefined, https);
    };

    return {

        /**
         * Getter for the windows object
         *
         * @return object
         */
        getWindows : function () {
            return windows;
        },

        /**
         * Receive a message from another domains frame.
         *
         * The object needs to be double wrapped.
         *
         * @param {object} event
         * @param {string} event.data The string passed from the domus domain. When parsed to JSON it contains the following :
         * @param {object} event.data.data Any data that is associated with the request.
         * @param {string} [event.data.action] The name of a action to be called on object
         *                                     paramater to validate and utilise the data.
         *                                     All valid actions start with 'action',
         *                                     but this is not included in the action name passed in.
         *                                     This only required for incoming requests for data and not
         *                                     responses to requests.
         * @param {string} [event.data.request_uuid] If this is a new request, then this is the uuid used by the
         *      requesting domain to identify the request.
         *      If this is a response to a request, then this is the uuid that was sent
         *      to the domus domain with the request. This is passed back to this domain with the results
         *      so that they can be matched to the request.
         * @param {string} [event.data.response_uuid] If this is a returning request, then this is the uuid generated
         *      by the other domain.
         *
         */
        receiveMessage : function (event) {
            //Abort if necessary data has not loaded yet.
            if (BabblingBrook.Domus.Loaded.ifUserAndAccessLoaded() === false) {
                console.error(event);
                console.error('domus/interact.js aborting. User data not loaded');
                throw 'Thread execution stopped.';
            }

            // Check if it is a ready request.
            if (event.data === 'readyrequest') {
                readyRequest(event.origin, event.source);
                return;
            }

            // Check if it is a logout request.
            if (event.data === 'logout') {
                logout();
                return;
            }

            var error = false;
            var https;
            var origin = event.origin;
            if (origin.substring(0, 8) === 'https://') {
                origin = origin.substring(8);        // remove https://
                https = true;
            } else {
                origin = origin.substring(7);        // remove http://
                https = false;
            }

            // Convert string to JSON
            var message = BabblingBrook.Library.parseJSON(event.data);

            if (!message) {
                reportError('Incoming message did not parse to JSON', event);
            }

            if (typeof message.request_uuid === 'undefined') {
                reportError('request_uuid is required.', event);
            }
            if (typeof message.action !== 'string' && typeof message.response_uuid === 'undefined') {
                reportError('Either a action name or a response_uuid is required.', event);
            }
            if (typeof message.response_uuid !== 'undefined' && typeof message.response_data !== 'object') {
                reportError('response_data is malformed or not a JSON object', event);
            }
            if (typeof message.response_uuid === 'undefined' && typeof message.request_data !== 'object') {
                reportError('request_data is malformed or not a JSON object', event);
            }

            if (typeof message.response_uuid === 'undefined' && typeof message.timeout === 'undefined') {
                reportError('Timeout is missing from message data.', event);
            }
            // Remove one second from the timeout so that errors are reported here before in the requesting domain.
            message.timeout = parseInt(message.timeout) - 1000;

            // Check if the domain is allowed access.
            var controller;
            if (origin.substr(0, 9) === 'scientia.') {
                // This is an untrusted domain. It can only access BabblingBrook.ScientiaActions.
                controller = BabblingBrook.Domus.ScientiaController;
            } else if (origin.substr(0, 7) === 'filter.' && origin.substr(7) === BabblingBrook.Domus.User.domain) {
                controller = BabblingBrook.Domus.FilterController;
            } else if (origin.substr(0, 11) === 'suggestion.' && origin.substr(11) === BabblingBrook.Domus.User.domain) {
                controller = BabblingBrook.Domus.SuggestionController;
            } else if (origin.substr(0, 8) === 'kindred.' && origin.substr(8) === BabblingBrook.Domus.User.domain) {
                controller = BabblingBrook.Domus.KindredController;
            } else if (origin.substr(0, 5) === 'ring.' && origin.substr(5) === BabblingBrook.Domus.User.domain) {
                controller = BabblingBrook.Domus.RingController;
            } else if (origin === BabblingBrook.Domus.User.domain) {
                controller = BabblingBrook.Domus.Controller;
                storeWindow(message.request_uuid, event.source);
            } else if (jQuery.inArray(origin, BabblingBrook.Domus.User.site_access) !== -1) {
                controller = BabblingBrook.Domus.Controller;
                storeWindow(message.request_uuid, event.source);
            } else {
                reportError('invalid domain attempting to access the domus domain: ' + origin, event);
            }

            if (typeof message.testing !== 'undefined') {
                BabblingBrook.Library.setCookie('testing', message.testing.toString());
            }

            var fn_name;
            // This is a request for data.
            if (typeof message.action === 'string') {
                // Call relevent function to process the message - stored in 'type'
                fn_name = 'action' + message.action;
                if (typeof controller[fn_name] === 'function') {
                    controller[fn_name](
                        message.request_data,
                        {
                            onSuccess : returnSuccessCallback.bind(null, message.request_uuid, origin, https),
                            onError : returnErrorCallback.bind(
                                null,
                                message.request_uuid,
                                origin,
                                https,
                                message.action,
                                message.request_data
                            ),
                            request_domain : origin,
                            timeout : message.timeout
                        }
                    );
                } else {
                    returnErrorCallback(
                        message.request_uuid,
                        origin,
                        https,
                        message.action,
                        message.request_data,
                        'domus_action_not_found'
                    );
                    reportError('domus/interact.js invalid action name provided : ' + message.action, event);
                }

            // This is a returning message
            } else if (typeof message.response_uuid === 'string') {
                var callback_container = callbacks[message.request_uuid];
                if (typeof callback_container !== 'object' || typeof callback_container.success !== 'function') {
                    reportError('The callback object for message returning to the domus is missing.', event);
                }
                // Is this an error returning or success?
                if (typeof message.response_data.error_code === 'string') {
                    callback_container.error(message.response_data.error_code, message.response_data.error_data, origin);
                } else {
                    callback_container.success(message.response_data, origin);
                }
                delete callbacks[message.request_uuid];

            // Something is wrong.
            } else {
                reportError('Request did not have a uuid.', event);
            }

        },

        /**
         * Post a message to the site being used.
         *
         * @param {object} request_data The data to send with the request.
         * @param {string} sub_domain The name of the sub_domain that is being called with the message.
         *      For scientia requests this needs to be the full domain.
         * @param {string} action The name of the action to call in the object (not including 'action' at the start).
         * @param {function} success The success callback
         * @param {function} [error] The error callback.
         * @param {string} [https = false] Is the remote iframe using SSL?
         * @param {number} [timeout = 30000] The number of milliseconds to wait before timing out a request.
         */
        postAMessage : function (request_data, sub_domain, action, success, error, https, timeout) {
            postMessage(request_data, sub_domain, undefined, action, success, error, https, timeout);
        }
    };
}());